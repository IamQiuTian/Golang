package main

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"gopkg.in/olivere/elastic.v6"
	"log"
	"net/smtp"
	"os"
	"reflect"
	"strings"
	"time"
)

type AutoGenerated struct {
	Index   string      `json:"_index"`
	Type    string      `json:"_type"`
	ID      string      `json:"_id"`
	Version int         `json:"_version"`
	Score   interface{} `json:"_score"`
	Source
	Beat
	Fields
	Sort []int64 `json:"sort"`
}

type Source struct {
	Timestamp time.Time `json:"@timestamp"`
	Source    string    `json:"source"`
	Offset    int       `json:"offset"`
	Message   string    `json:"message"`
	Prospector
}

type Prospector struct {
	Type string `json:"type"`
}

type Fields struct {
	Timestamp []time.Time `json:"@timestamp"`
}

type Beat struct {
	Version  string `json:"version"`
	Name     string `json:"name"`
	Hostname string `json:"hostname"`
}

var (
	host     string = "http://127.0.0.1:9200"
	in       int    = 1
	iplist          = []string{"172.17.1.1", "172.17.1.2", "172.17.1.3"}
	infoDict        = map[string]int{"172.17.1.1": 1, "172.17.1.2": 1, "172.17.1.3": 1}
	Mess            = bytes.NewBufferString("")
)

func main() {
	t1 := time.NewTimer(time.Minute * 1)

	for {
		select {
		case <-time.After(1 * time.Second):
			timeSr := time.Now().Format("2006.01.02")
			for _, ip := range iplist {
				err := Get_Message(timeSr, ip)
				if err != nil {
					continue
				}
			}

		case <-t1.C:
			if len(Mess.String()) != 0 {
				err := sendMail("日志报警", Mess.String())
				if err != nil {
					fmt.Println(err)
				} else {
					Mess.Write([]byte(""))
					t1 = time.NewTimer(time.Minute * 1)
				}
			}
		}
	}
}

func Get_Message(timeSr, indexName string) error {
	errorlog := log.New(os.Stdout, "ERROR:  ", log.LstdFlags)

	client, err := elastic.NewClient(elastic.SetErrorLog(errorlog), elastic.SetSniff(false), elastic.SetURL(host))
	if err != nil {
		panic(err)
	}
	exists, err := client.IndexExists(fmt.Sprintf("%s-%s", indexName, timeSr)).Do(context.Background())
	if err != nil {
		fmt.Println(err)
		return err
	}

	if !exists {
		fmt.Printf("%s Index does not exist\n", fmt.Sprintf("%s-%s", indexName, timeSr))
		return err
	}

	var ttyp AutoGenerated
	termQuery := elastic.NewTermQuery("_type", "doc")
	searchResult, err := client.Search().
		Index(fmt.Sprintf("%s-%s", indexName, timeSr)).
		Query(termQuery).
		From(infoDict[indexName]).Size(1).
		Pretty(true).
		Do(context.Background())

	if err != nil {
		return err
	}

	for _, item := range searchResult.Each(reflect.TypeOf(ttyp)) {
		if t, ok := item.(AutoGenerated); ok {
			if strings.Contains(t.Source.Message, "ERROR") || strings.Contains(t.Source.Message, "exception") || strings.Contains(t.Source.Message, "error") {
				Mess.Write([]byte(fmt.Sprintf("日志来源：%s\n日志文件路径: %s\n日志内容: %s", indexName, t.Source.Source, t.Source.Message+"\n\n")))
			}
		} else {
			return errors.New("Parsing failed")
		}
	}
	infoDict[indexName] = infoDict[indexName] + 1
	return nil
}

func sendMail(title, txt string) error {
	auth := smtp.PlainAuth("", "xxxx@xxx.cn", "****", "smtp.exmail.qq.com")
	to := []string{"xxxx.com"}
	nickname := "elk"
	user := "xxxx@xxx.cn"
	subject := title
	content_type := "Content-Type: text/plain; charset=UTF-8"
	body := txt
	msg := []byte("To: " + strings.Join(to, ",") + "\r\nFrom: " + nickname +
		"<" + user + ">\r\nSubject: " + subject + "\r\n" + content_type + "\r\n\r\n" + body)
	err := smtp.SendMail("smtp.exmail.qq.com:25", auth, user, to, msg)
	if err != nil {
		return err
	}
	return nil
}
