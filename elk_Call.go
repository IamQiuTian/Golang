package main

import (
	"context"
	"errors"
	"fmt"
	"gopkg.in/olivere/elastic.v6"
	"log"
	"net/smtp"
	"os"
	"reflect"
	"strings"
	"time"
)

type AutoGenerated struct {
	Index   string      `json:"_index"`
	Type    string      `json:"_type"`
	ID      string      `json:"_id"`
	Version int         `json:"_version"`
	Score   interface{} `json:"_score"`
	Source
	Beat
	Fields
	Sort []int64 `json:"sort"`
}

type Source struct {
	Timestamp time.Time `json:"@timestamp"`
	Source    string    `json:"source"`
	Offset    int       `json:"offset"`
	Message   string    `json:"message"`
	Prospector
}

type Prospector struct {
	Type string `json:"type"`
}

type Fields struct {
	Timestamp []time.Time `json:"@timestamp"`
}

type Beat struct {
	Version  string `json:"version"`
	Name     string `json:"name"`
	Hostname string `json:"hostname"`
}

var (
	host     string = "http://x.x.x.x:9200"
	in       int    = 1
	iplist          = []string{"x.x.x.x", "x.x.x.x", "x.x.x.x", "x.x.x.x", "x.x.x.x"}
	infoDict        = map[string]int{"x.x.x.x": 1, "x.x.x.x": 1, "x.x.x.x": 1, "x.x.x.x": 1, "x.x.x.x": 1}
)

func main() {
	for {
		select {
		case <-time.After(1 * time.Second):
			timeSr := time.Now().Format("2006.01.02")
			for _, ip := range iplist {
				err := Get_Message(timeSr, ip)
				if err != nil {
					continue
				}
			}
		}
	}
}

func Get_Message(timeSr, indexName string) error {
	errorlog := log.New(os.Stdout, "ERROR:  ", log.LstdFlags)

	client, err := elastic.NewClient(elastic.SetErrorLog(errorlog), elastic.SetSniff(false), elastic.SetURL(host))
	if err != nil {
		panic(err)
	}
	exists, err := client.IndexExists(fmt.Sprintf("%s-%s", indexName, timeSr)).Do(context.Background())
	if err != nil {
		panic(err)
	}

	if !exists {
		panic(err)
	}

	var ttyp AutoGenerated
	termQuery := elastic.NewTermQuery("_type", "doc")
	searchResult, err := client.Search().
		Index(fmt.Sprintf("%s-%s", indexName, timeSr)).
		Query(termQuery).
		From(infoDict[indexName]).Size(1).
		Pretty(true).
		Do(context.Background())

	if err != nil {
		return err
	}

	for _, item := range searchResult.Each(reflect.TypeOf(ttyp)) {
		if t, ok := item.(AutoGenerated); ok {
			if strings.Contains(t.Source.Message, "ERROR") || strings.Contains(t.Source.Message, "exception") || strings.Contains(t.Source.Message, "Failed") || strings.Contains(t.Source.Message, "WARN") {
				sendMail(fmt.Sprintf("%s 日志警告", indexName), fmt.Sprintf("日志来源：%s\n日志文件路径: %s\n日志内容: %s", indexName, t.Source.Source, t.Source.Message))
			}
		} else {
			return errors.New("Parsing failed")
		}
	}
	infoDict[indexName] = infoDict[indexName] + 1
	return nil
}

func sendMail(title, txt string) error {
	auth := smtp.PlainAuth("", "xxxx@163.com", "PASSWORD", "smtp.163.com")
	to := []string{"xxxx@163.com"}
	nickname := "xxxx"
	user := "xxxx@163.com"
	subject := title
	content_type := "Content-Type: text/plain; charset=UTF-8"
	body := txt
	msg := []byte("To: " + strings.Join(to, ",") + "\r\nFrom: " + nickname +
		"<" + user + ">\r\nSubject: " + subject + "\r\n" + content_type + "\r\n\r\n" + body)
	err := smtp.SendMail("smtp.163.com:25", auth, user, to, msg)
	if err != nil {
		return err
	}
	return nil
}
